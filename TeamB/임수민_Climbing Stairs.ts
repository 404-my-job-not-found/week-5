// Dynamic Programming은 정확하게 알고 있지 않아서 알고리즘에 대해 공부를 좀 하고 풀어봤습니다.
// Dynamic Programming 알고리즘이란
// 큰 문제를 풀기 전에 작은 문제들을 풀면서 결과를 저장해 나아가면서 전체 문제를 해결하는 알고리즘
// 일반적으로 재귀적으로 구현되고 Memoization 기법을 사용하는 것이 핵심인 것 같습니다.

// 그럼 작은 문제들부터 차근차근 머리로 그려 나가 보면
// n = 1 : 1가지 방법
// 시작 => [1] => 도착
// 1가지 방법

// n = 2 : 2가지 방법
// 시작 => [1] => [1] => 도착
// 시작 => [2] 도착
// 2가지 방법

// n = 3 : 3가지 방법
// 시작 => [1] => [1] => [1] => 도착
// 시작 => [2] => [1] => 도착
// 시작 => [1] => [2] => 도착

// n = 4 => 5가지 방법
// 시작 => [1] => [1] => [1] => [1] => 도착
// 시작 => [1] => [1] => [2] => 도착
// 시작 => [1] => [2] => [1] => 도착
// 시작 => [2] => [1] => [1] => 도착
// 시작 => [2] => [2] => 도착

// n = 5 => 8가지 방법
// 시작 => [1] => [1] => [1] => [1] => [1] => 도착
// 시작 => [1] => [1] => [1] => [2] => 도착
// 시작 => [1] => [1] => [2] => [1] => 도착
// 시작 => [1] => [2] => [1] => [1] => 도착
// 시작 => [2] => [1] => [1] => [1] => 도착
// 시작 => [2] => [1] => [2] => 도착
// 시작 => [2] => [2] => [1] => 도착
// 시작 => [2] => [2] => [2] => 도착

// 그려 본다면 이렇게 피보나치 패턴이 나오는 것을 볼 수 있습니다.
// 잘 보면 패턴이 보이게 되는데 n이 5일 때 방법의 갯수는 n = 3 일 때와 n = 4 일 때 방법의 갯수를 더한 것과 같은데
// 이는 피보나치 패턴과 동일했습니다. 피보나치 패턴은 일반 항으로 표현하면 f(n) = f(n-1) + f(n-2) 이런 식으로 표현되는데 이를 그대로 함수에 적용하면 될 것 같습니다.

// 첫번 째 시도
// 피보나치 일반항으로 표현했던 것을 그대로 함수에 적용한 로직인데,
// Maximum call stack size exceeded 에러가 발생 했습니다.
// 아마 기저조건이 추가되지 않아서 재귀 호출이 음수까지 깊어지는 것 같습니다
// function climbStairs(n: number): number {
//   return climbStairs(n - 1) + climbStairs(n - 2);
// }

// 두번 째 시도
// 기저조건을 추가하고 재귀 호출을 줄였지만 여전히 Time Limit Exceeded가 발생했습니다..
// 결국 재귀로 돌리면 스택 오버 플로우가 발생하기 때문에 재귀 호출로는 풀지 말아야 할 것 같습니다.
// 이 내용은 예전에 피보나치 수를 학습하고 블로그에 정리해 놓은 내용에 있습니다
// https://s-o-o-min.tistory.com/entry/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%F0%9F%98%88-JavaScript-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98
// function climbStairs(n: number): number {
//   if (n <= 2) return n;
//   return climbStairs(n - 1) + climbStairs(n - 2);
// }

// 세번 째 시도
// 결국 스택오버 플로우가 일어나는 이유는 재귀 호출에서 중복계산이 일어나기 때문에 발생하는 것인데...
// 이런 경우엔 위에서 설명했던 DP 알고리즘에 핵심인 계산된 값을 배열에 저장하는 메모제이션을 사용하면 될 것 같습니다.
// answer에 들어가있는 value는 계단을 오르는 방법의 갯수를 저장하고,
// n이 1,2 일때는 이미 answer에 저장 했기에 3번째 부터 계산하면 됩니다.
// i번째 인덱스의 값은 i-1번째 인덱스의 값과 i-2번째 인덱스의 값을 더한 값이 됩니다.

// n=3: answer[3] = answer[2] + answer[1] = 2 + 1 = 3
// n=4: answer[4] = answer[3] + answer[2] = 3 + 2 = 5
// n=5: answer[5] = answer[4] + answer[3] = 5 + 3 = 8

// n=44 일 때 answer에 담긴 value는
// [
//            0,         1,         2,         3,
//            5,         8,        13,        21,
//           34,        55,        89,       144,
//          233,       377,       610,       987,
//         1597,      2584,      4181,      6765,
//        10946,     17711,     28657,     46368,
//        75025,    121393,    196418,    317811,
//       514229,    832040,   1346269,   2178309,
//      3524578,   5702887,   9227465,  14930352,
//     24157817,  39088169,  63245986, 102334155,
//    165580141, 267914296, 433494437, 701408733,
//   1134903170
// ]
// 이렇게 되고 반복문은 n까지 돌면 되기 때문에 마지막 return은 answer[n] 이 됩니다.

function climbStairs(n: number): number {
  let answer = [0, 1, 2];
  for (let i = 3; i <= n; i++) {
    answer[i] = answer[i - 1] + answer[i - 2];
  }
  return answer[n];
}

console.log(climbStairs(2));
console.log(climbStairs(3));
console.log(climbStairs(44));
